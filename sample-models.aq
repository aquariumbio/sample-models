{"config":{"title":"Sample Models for Aquarium Protocols","description":"Wrappers that provide easy access to, and computations on, attributes of Aquarium Samples","copyright":"University of Washington","version":"0.0.1","authors":[{"name":"Devin Strickland","affiliation":"University of Washington"}],"maintainer":{"name":"Devin Strickland","email":"dvn.strcklnd@gmail.com"},"acknowledgements":null,"github":{"user":"aquariumbio","repo":"aq-sample-models"},"keywords":null,"aquadoc_version":"1.0.2","aquarium_version":"\u003c%= Bioturk::Application.config.aquarium_version %\u003e"},"components":[{"library":{"name":"AbstractSample","category":"Sample Models","code_source":"class AbstractSample\n\n    attr_accessor :item, :sample, :properties\n\n    # Instantiates a new AbstractSample\n    #\n    # @param sample [Sample] Sample\n    # @return [AbstractSample]\n    def initialize(sample:, expected_sample_type:)\n        @sample = sample\n        @properties = sample.properties\n\n        is_expected_type?(expected_sample_type)\n    end\n\n    # Test whether a Sample is of the expected type\n    #\n    # @param test_sample [Sample]\n    # @return [Boolean]\n    def is_expected_type?(expected_sample_type)\n        unless sample \u0026\u0026 sample.sample_type.name == expected_sample_type\n            msg = \"Sample #{sample.id}, #{sample.sample_type.name}, is not a #{expected_sample_type}.\"\n            raise WrongSampleTypeError.new(msg)\n        end\n    end\n\n    # The name of the sample\n    #\n    # @return [String]\n    def name\n        sample.name\n    end\n\n    # Fetches a property based on its name\n    #\n    # @param property [String] the name of the property\n    # @return [Object] whatever the property points to\n    def fetch(property)\n        properties.fetch(property)\n    end\nend\n\nclass WrongSampleTypeError \u003c StandardError\n\nend"}},{"library":{"name":"DNALibrary","category":"Sample Models","code_source":"needs \"Sample Models/AbstractSample\"\n\nclass DNALibrary \u003c AbstractSample\n\n    THIS_SAMPLE_TYPE = \"DNALibrary\"\n    OLIGO_POOL = \"Oligo Pool\"\n\n    # Instantiates a new DNALibrary\n    #\n    # @param sample [Sample] Sample of SampleType \"DNALibrary\"\n    # @return DNALibrary\n    def initialize(sample:)\n        super(sample: sample, expected_sample_type: THIS_SAMPLE_TYPE)\n    end\n\n    def self.from_item(item)\n        DNALibrary.new(sample: item.sample)\n    end\n\n    def oligo_pool\n        fetch(OLIGO_POOL)\n    end\n    \nend"}},{"library":{"name":"OligoPool","category":"Sample Models","code_source":"needs \"Sample Models/AbstractSample\"\n\nclass OligoPool \u003c AbstractSample\n\n    THIS_SAMPLE_TYPE = \"Oligo Pool\"\n    MANUFACTURER = \"Manufacturer\"\n    OLIGO_POOL_ID = \"Oligo Library ID\"\n    MIN_LENGTH = \"min length (nt) (array)\"\n    MAX_LENGTH = \"max length (nt) (array)\"\n    VARIANTS = \"variants (array)\"\n    NAMES = \"sublibrary name (array)\"\n    FORWARD_PRIMING_SITE = \"forward priming site (array)\"\n    REVERSE_PRIMING_SITE = \"reverse priming site (array)\"\n\n    # Instantiates a new OligoPool\n    #\n    # @param sample [Sample] Sample of SampleType \"Oligo Pool\"\n    # @return [OligoPool]\n    def initialize(sample:)\n        super(sample: sample, expected_sample_type: THIS_SAMPLE_TYPE)\n    end\n\n    def self.from_item(item)\n        OligoPool.new(sample: item.sample)\n    end\n\n    def primers_valid?(forward_primer:, reverse_primer:, sublibrary_name:)\n        primers = [forward_primer, reverse_primer]\n        sites = [\n            forward_priming_site(sublibrary_name),\n            reverse_priming_site(sublibrary_name)\n        ]\n\n        bindings = Primer.get_bindings(primers: primers, sites: sites)\n        bindings.length == 2\n    end\n\n    def manufacturer\n        properties.fetch(MANUFACTURER)\n    end\n\n    def oligo_library_id\n        oligo_pool_id\n    end\n\n    def oligo_pool_id\n        properties.fetch(OLIGO_POOL_ID)\n    end\n\n    def min_length(sublibrary_name)\n        fetch(MIN_LENGTH, sublibrary_name)\n    end\n\n    def max_length(sublibrary_name)\n        fetch(MAX_LENGTH, sublibrary_name)\n    end\n\n    def lengths(sublibrary_name)\n        [min_length(sublibrary_name), max_length(sublibrary_name)]\n    end\n\n    def forward_priming_site(sublibrary_name)\n        fetch(FORWARD_PRIMING_SITE, sublibrary_name)\n    end\n\n    def reverse_priming_site(sublibrary_name)\n        fetch(REVERSE_PRIMING_SITE, sublibrary_name)\n    end\n\n    def priming_sites(sublibrary_name)\n        [\n            forward_priming_site(sublibrary_name),\n            reverse_priming_site(sublibrary_name)\n        ]\n    end\n\n    def variants(sublibrary_name)\n        fetch(VARIANTS, sublibrary_name)\n    end\n\n    def fetch(property, sublibrary_name)\n        properties.fetch(property)[sublibrary_index(sublibrary_name)]\n    end\n\n    def sublibrary_index(sublibrary_name)\n        index = names.find_index(sublibrary_name)\n        unless index\n            raise SublibraryIndexError.new(\"#{sublibrary_name} not found in #{names}.\")\n        end\n        index\n    end\n\n    def names\n        properties.fetch(NAMES)\n    end\n\nend\n\nclass SublibraryIndexError \u003c StandardError\n\nend"}},{"library":{"name":"Primer","category":"Sample Models","code_source":"needs \"Sample Models/AbstractSample\"\n\n# frozen_string_literal: true\n\n# Defines the Primer class with methods to manage the properties of primers,\n#   such as sequence, length, priming site, etc.\nclass Primer \u003c AbstractSample\n\n    THIS_SAMPLE_TYPE = \"Primer\"\n    OVERHANG_SEQUENCE = \"Overhang Sequence\"\n    ANNEAL_SEQUENCE = \"Anneal Sequence\"\n    T_ANNEAL = \"T Anneal\"\n    private_constant(\n      :THIS_SAMPLE_TYPE, :OVERHANG_SEQUENCE, :ANNEAL_SEQUENCE, :T_ANNEAL\n    )\n\n    # Instantiates a new Primer\n    #\n    # @param sample [Sample] Sample of SampleType \"Primer\"\n    # @return [Primer]\n    def initialize(sample:)\n        super(sample: sample, expected_sample_type: THIS_SAMPLE_TYPE)\n    end\n\n    # Instantiates a new Primer from an Item\n    #\n    # @param item [Item] Item of a Sample of SampleType \"Primer\"\n    # @return [Primer]\n    def self.from_item(item)\n        Primer.new(sample: item.sample)\n    end\n\n    # The overhang sequence\n    #\n    # @return [String]\n    def overhang_sequence\n        fetch(OVERHANG_SEQUENCE).strip\n    end\n\n    # The anneal sequence\n    #\n    # @return [String]\n    def anneal_sequence\n        fetch(ANNEAL_SEQUENCE).strip\n    end\n\n    # The full sequence of the primer\n    #\n    # @return [String]\n    def sequence\n        overhang_sequence + anneal_sequence\n    end\n\n    # The length of the primer in nt\n    #\n    # @return [FixNum]\n    def length\n        sequence.length\n    end\n\n    # The annealing temperature of the primer\n    #\n    # @note This is the temperature as it is entered into the database. It is not\n    #   calculated and may be inacurate depending on the template.\n    # @return [FixNum]\n    def t_anneal\n        fetch(T_ANNEAL)\n    end\n\n    # Finds binding sites for a set of primers on a set of templates\n    #\n    # @param primers [Array\u003cPrimer\u003e] the primers\n    # @param sites [Array\u003cString\u003e] the templates to be scanned\n    # @return [Array\u003cHash\u003e]\n    def self.get_bindings(primers:, sites:)\n        bindings = []\n        primers.each do |primer|\n            sites.each do |site|\n                offset = primer.detect_priming_site(template: site)\n                if offset\n                    added_length = primer.sequence.length - offset[1]\n\n                    if added_length \u003c 0\n                        raise \"Primer model detected binding site longer than the primer sequence.\"\n                    end\n\n                    b = {\n                        primer: primer,\n                        site: site,\n                        offset: offset,\n                        added_length: added_length\n                    }\n                    bindings.append(b)\n                    sites.delete(site)\n                    break\n                end\n            end\n        end\n        bindings\n    end\n\n    # Finds the first binding site for a Primer on a template\n    #\n    # @todo make this work with multiple matches and internal matches\n    # @param template [String] the template sequence\n    # @param min_length [FixNum] the minimum length of the binding site\n    # @param require_perfect [FixNum] the number of nt from the 3' end that must match perfectly\n    # @param allow_mismatch [FixNum] the number of mismatches allowed (doesn't do anything currently)\n    # @return [Array\u003cFixNum\u003e]\n    def detect_priming_site(template:, min_length: 16, require_perfect: 3, allow_mismatch: 1)\n        query = last(require_perfect)\n        matches = scan(template, query)\n        matches.delete_if { |m| m.offset(0)[1] \u003c min_length }\n        return if matches.blank?\n\n        i = 0\n        loop do\n            break if matches.length \u003c= 1\n            i += 1\n            query = last(require_perfect + i)\n            matches.keep_if { |m| expand_match(template, m, i) =~ /#{query}/i }\n        end\n\n        start, stop = matches[0].offset(0)\n        return unless template[0..stop] =~ /#{last(stop)}/i\n        [0, stop]\n    end\n\n    # The last n nucleotides of the sequence\n    #\n    # @param n [FixNum]\n    # @return [String]\n    def last(n)\n        sequence[-n..-1]\n    end\n\n    # Scans the template with a pattern and returns an array of MatchData objects\n    #\n    # @param template [String] the sequence to be scanned\n    # @param pat [String] the sequence to scan for\n    # @return [Array\u003cMatchData\u003e]\n    def scan(template, pat)\n        template.to_enum(:scan, /#{pat}/i).map { Regexp.last_match }\n    end\n\n    def expand_match(template, match, i)\n        start, stop = match.offset(0)\n        template[start - i..stop]\n    end\n\nend\n\nclass IncompatiblePrimingSitesError \u003c StandardError\n\nend"}}]}